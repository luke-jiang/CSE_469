// Bubble-sort of 10 element array, Mem[0],Mem[8],..Mem[72]
// for (X0 = 9; X0 > 0; X0--) {
//   for (X1 = 0; X1 < X0; X1++) {
//     if (A[X1+1] < A[X1]) SWAP(A[X1+1],A[X1]);
//   }
// }

// Requires:
// ADDI, ADDS, B, B.LT, CBZ, LDUR, STUR & SUBS instructions
// Expected results:
// X11      =  1
// X12      =  2
// X13      =  3
// X14      =  4
// X15      =  5
// X16      =  6
// X17      =  7
// X18      =  8
// X19      =  9
// X20      = 10

//ADDI: I-type, Reg[Rd] = Reg[Rn] + {'0, Imm12}
//OP         Imm12        Rn    Rd
//3322222222 221111111111 00000 00000
//1098765432 109876543210 98765 43210
//1001000100 Unsigned     0..31 0..31

//B: B-type, PC = PC + SignExtend({Imm26, 2'b00})
//OP     Imm26
//332222 22222211111111110000000000
//109876 54321098765432109876543210
//000101 2's Comp Imm26

//B.cond: CB-type, if (flags meet condition) PC = PC + SignExtend({Imm19, 2'b00})
//OP       Imm19               Cond
//33222222 2222111111111100000 00000
//10987654 3210987654321098765 43210
//01010100 2's Comp Imm19      0..15

//CBZ: CB-type, if (R[Rt] == 0) PC = PC + SignExtend({Imm19, 2'b00})
//OP       Imm19               Rt
//33222222 2222111111111100000 00000
//10987654 3210987654321098765 43210
//10110100 2's Comp Imm19      0..31

//LDUR: D-type, Reg[Rt] = Mem[Reg[Rn] + SignExtend(Imm9)]
//OP          Imm9      00 Rn    Rt
//33222222222 211111111 11 00000 00000
//10987654321 098765432 10 98765 43210
//11111000010 2's Comp  00 0..31 0..31

//STUR: D-type, Mem[Reg[Rn] + SignExtend(Imm9)] = Reg[Rt]
//OP          Imm9      00 Rn    Rt
//33222222222 211111111 11 00000 00000
//10987654321 098765432 10 98765 43210
//11111000000 2's Comp  00 0..31 0..31

//SUBS: R-type, Reg[Rd] = Reg[Rn] - Reg[Rm]
//OP          Rm    Shamt  Rn    Rd
//33222222222 21111 111111 00000 00000
//10987654321 09876 543210 98765 43210
//11101011000 0..31 000000 0..31 0..31

         // STORE_VALS:
1001000100_000000001010_11111_00000    // ADDI X0, X31, #10
11111000000_000000000_00_11111_00000   // STUR X0, [X31, #0]   // Mem[0] = 10
1001000100_000000000111_11111_00000    // ADDI X0, X31, #7
11111000000_000001000_00_11111_00000   // STUR X0, [X31, #8]   // Mem[8] = 7
1001000100_000000000100_11111_00000    // ADDI X0, X31, #4
11111000000_000010000_00_11111_00000   // STUR X0, [X31, #16]  // Mem[16] = 4
1001000100_000000001001_11111_00000    // ADDI X0, X31, #9
11111000000_000011000_00_11111_00000   // STUR X0, [X31, #24]  // Mem[24] = 9
1001000100_000000000011_11111_00000    // ADDI X0, X31, #3
11111000000_000100000_00_11111_00000   // STUR X0, [X31, #32]  // Mem[32] = 3
1001000100_000000001000_11111_00000    // ADDI X0, X31, #8
11111000000_000101000_00_11111_00000   // STUR X0, [X31, #40]  // Mem[40] = 8
1001000100_000000000010_11111_00000    // ADDI X0, X31, #2
11111000000_000110000_00_11111_00000   // STUR X0, [X31, #48]  // Mem[48] = 2
1001000100_000000000101_11111_00000    // ADDI X0, X31, #5
11111000000_000111000_00_11111_00000   // STUR X0, [X31, #56]  // Mem[56] = 5
1001000100_000000000110_11111_00000    // ADDI X0, X31, #6
11111000000_001000000_00_11111_00000   // STUR X0, [X31, #64]  // Mem[64] = 6
1001000100_000000000001_11111_00000    // ADDI X0, X31, #1
11111000000_001001000_00_11111_00000   // STUR X0, [X31, #72]  // Mem[72] = 1
   // MAIN:
1001000100_000000000001_11111_00101    // ADDI X5, X31, #1     // Need a constant 1 for decr
1001000100_000000001001_11111_00000    // ADDI X0, X31, #9     // for (X0 = 9; X0 > 0; X0--) {
   // OUTER_LOOP:
1001000100_000000000000_11111_00001    // ADDI X1, X31, #0     // for (X1 = 0; X1 < X0; X1++) {
10101011000_00001_000000_00001_00100   // ADDS X4, X1, X1      // For addressing, X4=8*X1
   // INNER_LOOP:
11111000010_000001000_00_00100_00011   // LDUR X3, [X4, #8]    // get A[X1+1]
11111000010_000000000_00_00100_00010   // LDUR X2, [X4, #0]    // get A[X1]  
1001000100_000000000000_11111_11111    // ADDI X31, X31, #0    // NOOP             
11101011000_00011_000000_00010_11111   // SUBS X31, X2, X3     // Test X2 vs. X3
01010100_0000000000000000100_01011     // B.LT NO_SWAP         // Don't swap if X2 < X3
1001000100_000000000000_11111_11111    // ADDI X31, X31, #0    // NOOP
11111000000_000001000_00_00100_00010   // STUR X2, [X4, #8]    // swap A[X1]
11111000000_000000000_00_00100_00011   // STUR X3, [X4, #0]    // swap A[X1-1]
   // NO_SWAP:
1001000100_000000000001_00001_00001    // ADDI X1, X1, #1      // X1++
1001000100_000000001000_00100_00100    // ADDI X4, X4, #8      // Keep X4=8*X1
11101011000_00000_000000_00001_11111   // SUBS X31, X1, X0     // Is X1 < X0?
01010100_1111111111111110101_01011     // B.LT INNER_LOOP      // If so, continue inner loop
1001000100_000000000000_11111_11111    // ADDI X31, X31, #0    // NOOP
   // DONE_INNER:
11101011000_00101_000000_00000_00000   // SUBS X0, X0, X5      // X0--
10110100_0000000000000000100_00000     // CBZ X0, DONE_OUTER   // End outer loop when done
1001000100_000000000000_11111_11111    // ADDI X31, X31, #0    // NOOP
000101_11111111111111111111101110      // B OUTER_LOOP         // Continue outer loop
1001000100_000000000000_11111_11111    // ADDI X31, X31, #0    // NOOP
   // DONE_OUTER:
11111000010_000000000_00_11111_01011   // LDUR X11, [X31, #0]  // Read back values to regs X11-X20
11111000010_000001000_00_11111_01100   // LDUR X12, [X31, #8]
11111000010_000010000_00_11111_01101   // LDUR X13, [X31, #16]
11111000010_000011000_00_11111_01110   // LDUR X14, [X31, #24]
11111000010_000100000_00_11111_01111   // LDUR X15, [X31, #32]
11111000010_000101000_00_11111_10000   // LDUR X16, [X31, #40]
11111000010_000110000_00_11111_10001   // LDUR X17, [X31, #48]
11111000010_000111000_00_11111_10010   // LDUR X18, [X31, #56]
11111000010_001000000_00_11111_10011   // LDUR X19, [X31, #64]
11111000010_001001000_00_11111_10100   // LDUR X20, [X31, #72]
   // HALT:
000101_00000000000000000000000000      // B HALT               // HALT
1001000100_000000000000_11111_11111    // ADDI X31, X31, #0    // NOOP
