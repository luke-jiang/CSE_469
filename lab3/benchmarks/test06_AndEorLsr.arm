// Test of AND, EOR, LSR instructions.
// Requires:
// ADDI, AND, B, EOR & LSR instructions
// Expected results (HEX):
// X0 = 0xACE
// X1 = 0xA
// X2 = 0xC
// X3 = 0x0

//ADDI: I-type, Reg[Rd] = Reg[Rn] + {'0, Imm12}
//OP         Imm12        Rn    Rd
//3322222222 221111111111 00000 00000
//1098765432 109876543210 98765 43210
//1001000100 Unsigned     0..31 0..31

//AND: R-type, Reg[Rd] = Reg[Rn] & Reg[Rm]
//OP          Rm    Shamt  Rn    Rd
//33222222222 21111 111111 00000 00000
//10987654321 09876 543210 98765 43210
//10001010000 0..31 000000 0..31 0..31

//B: B-type, PC = PC + SignExtend({Imm26, 2'b00})
//OP     Imm26
//332222 22222211111111110000000000
//109876 54321098765432109876543210
//000101 2's Comp Imm26

//EOR: R-type, Reg[Rd] = Reg[Rn] ^ Reg[Rm]
//OP          Rm    Shamt  Rn    Rd
//33222222222 21111 111111 00000 00000
//10987654321 09876 543210 98765 43210
//11001010000 0..31 000000 0..31 0..31

//LSR: R-type, Reg[Rd] = Reg[Rn] >> shamt (no sign extend)
//OP          Rm    Shamt  Rn    Rd
//33222222222 21111 111111 00000 00000
//10987654321 09876 543210 98765 43210
//11010011010 00000 0...63 0..31 0..31

1001000100_101110101101_11111_00000    // ADDI X0, X31, #2989     // X0 = 2989
1001000100_101100011101_11111_00001    // ADDI X1, X31, #2845     // X1 = 2845
11010011010_00000_000011_00001_00010   // LSR X2, X1, #3          // X2 = X1 >> 3
11001010000_00010_000000_00000_00000   // EOR X0, X0, X2          // X0 = X0 ^ X2
10001010000_00000_000000_00001_00001   // AND X1, X1, X0          // X1 = X1 & X0
11001010000_00001_000000_00000_00010   // EOR X2, X0, X1          // X2 = X0 ^ X1
10001010000_00001_000000_00010_00011   // AND X3, X2, X1          // X3 = X2 & X1
11010011010_00000_001000_00001_00001   // LSR X1, X1, #8          // X1 = X1 >> 8
11010011010_00000_000100_00010_00010   // LSR X2, X2, #4          // X2 = X2 >> 4
000101_00000000000000000000000000      // B HALT (0)
1001000100_000000000000_11111_11111    // ADDI X31, X31, #0       // NOOP