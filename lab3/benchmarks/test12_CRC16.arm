// Test of CRC-16 computation on a sample string.

//#define CRCPOLY 0xA001
//int crc16_bit(unsigned char *buffer, int length) {
// int i, j;
// unsigned int crcreg = 0;
//
// for (j = 0; j < length; ++j) {
//    unsigned char b = buffer[j];
//    for (i = 0; i < 8; ++i) {
//       if ((crcreg ^ b) & 1) {
//          crcreg = (crcreg >> 1) ^ CRCPOLY;
//       } else {
//          crcreg >>= 1;
//       }
//       b >>= 1;
//    }
// }
// return crcreg;
//}

// Requires:
// ADDI, ADDS, AND, B, CBZ, EOR, LSR & SUBS instructions
// Expected results (HEX):
//X0  = 0xA001 (CRC polynomial)
//X1  = 0x9476 (CRC for string "String 01234")
//X2  = 0xC
//X3  = 0x60
//X4  = 0x8
//X5  = 0x0
//X6  = 0x1
//X7  = 0x0
//X8  = 0x1
//X9  = 0xC
//X10 = 0x8

//ADDI: I-type, Reg[Rd] = Reg[Rn] + {'0, Imm12}
//OP         Imm12        Rn    Rd
//3322222222 221111111111 00000 00000
//1098765432 109876543210 98765 43210
//1001000100 Unsigned     0..31 0..31

//AND: R-type, Reg[Rd] = Reg[Rn] & Reg[Rm]
//OP          Rm    Shamt  Rn    Rd
//33222222222 21111 111111 00000 00000
//10987654321 09876 543210 98765 43210
//10001010000 0..31 000000 0..31 0..31

//B: B-type, PC = PC + SignExtend({Imm26, 2'b00})
//OP     Imm26
//332222 22222211111111110000000000
//109876 54321098765432109876543210
//000101 2's Comp Imm26

//B.cond: CB-type, if (flags meet condition) PC = PC + SignExtend({Imm19, 2'b00})
//OP       Imm19               Cond
//33222222 2222111111111100000 00000
//10987654 3210987654321098765 43210
//01010100 2's Comp Imm19      0..15
// Cond  Name Meaning after SUBS FlagTest
// 01011 LT    Signed <        N!=V

//CBZ: CB-type, if (R[Rt] == 0) PC = PC + SignExtend({Imm19, 2'b00})
//OP       Imm19               Rt
//33222222 2222111111111100000 00000
//10987654 3210987654321098765 43210
//10110100 2's Comp Imm19      0..31

//EOR: R-type, Reg[Rd] = Reg[Rn] ^ Reg[Rm]
//OP          Rm    Shamt  Rn    Rd
//33222222222 21111 111111 00000 00000
//10987654321 09876 543210 98765 43210
//11001010000 0..31 000000 0..31 0..31

//LDUR: D-type, Reg[Rt] = Mem[Reg[Rn] + SignExtend(Imm9)]
//OP          Imm9      00 Rn    Rt
//33222222222 211111111 11 00000 00000
//10987654321 098765432 10 98765 43210
//11111000010 2's Comp  00 0..31 0..31

//LSR: R-type, Reg[Rd] = Reg[Rn] >> shamt (no sign extend)
//OP          Rm    Shamt  Rn    Rd
//33222222222 21111 111111 00000 00000
//10987654321 09876 543210 98765 43210
//11010011010 00000 0...63 0..31 0..31

//STUR: D-type, Mem[Reg[Rn] + SignExtend(Imm9)] = Reg[Rt]
//OP          Imm9      00 Rn    Rt
//33222222222 211111111 11 00000 00000
//10987654321 098765432 10 98765 43210
//11111000000 2's Comp  00 0..31 0..31

//SUBS: R-type, Reg[Rd] = Reg[Rn] - Reg[Rm]
//OP          Rm    Shamt  Rn    Rd
//33222222222 21111 111111 00000 00000
//10987654321 09876 543210 98765 43210
//11101011000 0..31 000000 0..31 0..31

            // BUILD_STRING:
1001000100_000001010011_11111_00000    // ADDI X0, X31, #83       // X0: 'S'
11111000000_000000000_00_11111_00000   // STUR X0, [X31, #0]      // Mem[0] = 'S'
1001000100_000001110100_11111_00000    // ADDI X0, X31, #116      // X0: 't'
11111000000_000001000_00_11111_00000   // STUR X0, [X31, #8]      // Mem[8] = 't'
1001000100_000001110010_11111_00000    // ADDI X0, X31, #114      // X0: 'r'
11111000000_000010000_00_11111_00000   // STUR X0, [X31, #16]     // Mem[16] = 'r'
1001000100_000001101001_11111_00000    // ADDI X0, X31, #105      // X0: 'i'
11111000000_000011000_00_11111_00000   // STUR X0, [X31, #24]     // Mem[24] = 'i'
1001000100_000001101110_11111_00000    // ADDI X0, X31, #110      // X0: 'n'
11111000000_000100000_00_11111_00000   // STUR X0, [X31, #32]     // Mem[32] = 'n'
1001000100_000001100111_11111_00000    // ADDI X0, X31, #103      // X0: 'g'
11111000000_000101000_00_11111_00000   // STUR X0, [X31, #40]     // Mem[40] = 'g'
1001000100_000000100000_11111_00000    // ADDI X0, X31, #32       // X0: ' '
11111000000_000110000_00_11111_00000   // STUR X0, [X31, #48]     // Mem[48] = ' '
1001000100_000000110000_11111_00000    // ADDI X0, X31, #48       // X0: '0'
11111000000_000111000_00_11111_00000   // STUR X0, [X31, #56]     // Mem[56] = '0'
1001000100_000000110001_11111_00000    // ADDI X0, X31, #49       // X0: '1'
11111000000_001000000_00_11111_00000   // STUR X0, [X31, #64]     // Mem[64] = '1'
1001000100_000000110010_11111_00000    // ADDI X0, X31, #50       // X0: '2'
11111000000_001001000_00_11111_00000   // STUR X0, [X31, #72]     // Mem[72] = '2'
1001000100_000000110011_11111_00000    // ADDI X0, X31, #51       // X0: '3'
11111000000_001010000_00_11111_00000   // STUR X0, [X31, #80]     // Mem[80] = '3'
1001000100_000000110100_11111_00000    // ADDI X0, X31, #52       // X0: '4'
11111000000_001011000_00_11111_00000   // STUR X0, [X31, #88]     // Mem[88] = '4'
            // BUILD_POLY:
1001000100_000000000000_11111_00000    // ADDI X0, X31, #0        // for (i = 0; i < 10; i++)
1001000100_000000001010_11111_00001    // ADDI X1, X31, #10
1001000100_000000000000_11111_00010    // ADDI X2, X31, #0
1001000100_111111111111_00010_00010    // ADDI X2, X2, #4095
1001000100_000000000001_00000_00000    // ADDI X0, X0, #1         // i++
11101011000_00001_000000_00000_11111   // SUBS X31, X0, X1        // is i < 10?
01010100_1111111111111111101_01011     // B.LT BUILD_POLY+3       // If so, continue loop
1001000100_000000000000_11111_11111    // ADDI X31, X31, #0       // NOOP
1001000100_000000001011_00010_00010    // ADDI X2, X2, #11
            // MAIN:
1001000100_000000000000_00010_00000    // ADDI X0, X2, #0         // X0: #define CRCPOLY 0xA001
1001000100_000000000000_11111_00001    // ADDI X1, X31, #0        // X1: unsigned int crcreg = 0;
1001000100_000000000001_11111_01000    // ADDI X8, X31, #1        // Need a constant 1 for &
1001000100_000000001100_11111_01001    // ADDI X9, X31, #12       // Need a constant 12 for branch check
1001000100_000000001000_11111_01010    // ADDI X10, X31, #8       // Need a constant 8 for branch check
1001000100_000000000000_11111_00010    // ADDI X2, X31, #0        // for (j = 0; j < 12; ++j) {
1001000100_000000000000_11111_00011    // ADDI X3, X31, #0        // For addressing, X3=8*X2
            // OUTER_LOOP:
1001000100_000000000000_11111_00100    // ADDI X4, X31, #0        // for (i = 0; i < 8; ++i) {
11111000010_000000000_00_00011_00101   // LDUR X5, [X3, #0]       // unsigned char b = buffer[j];
1001000100_000000000000_11111_11111    // ADDI X31, X31, #0       // NOOP
            // INNER_LOOP:
11001010000_00001_000000_00101_00110   // EOR X6, X5, X1          // crcreg ^ b
10001010000_01000_000000_00110_00110   // AND X6, X6, X8          // (crcreg ^ b) & 1
11101011000_01000_000000_00110_00111   // SUBS X7, X6, X8         // if ((crcreg ^ b) & 1)
10110100_0000000000000000101_00111     // CBZ X7, SHIFT_CRCREG (+5)
1001000100_000000000000_11111_11111    // ADDI X31, X31, #0       // NOOP
            // ELSE:
11010011010_00000_000001_00001_00001   // LSR X1, X1, #1          // crcreg >>= 1;
000101_00000000000000000000000100      // B SHIFT_B (+4)
1001000100_000000000000_11111_11111    // ADDI X31, X31, #0       // NOOP
            // SHIFT_CRCREG:
11010011010_00000_000001_00001_00001   // LSR X1, X1, #1          // crcreg >>= 1;
11001010000_00000_000000_00001_00001   // EOR X1, X1, X0          // crcreg = crcreg ^ CRCPOLY
            // SHIFT_B:
11010011010_00000_000001_00101_00101   // LSR X5, X5, #1          // b >>= 1;
1001000100_000000000001_00100_00100    // ADDI X4, X4, #1         // i++
11101011000_01010_000000_00100_11111   // SUBS X31, X4, X10       // is i < 8?
01010100_1111111111111110011_01011     // B.LT INNER_LOOP (-13)   // If so, continue inner loop
1001000100_000000000000_11111_11111    // ADDI X31, X31, #0       // NOOP
            // DONE_INNER:
1001000100_000000000001_00010_00010    // ADDI X2, X2, #1         // j++
1001000100_000000001000_00011_00011    // ADDI X3, X3, #8         // Keep X3=8*X2
11101011000_01001_000000_00010_11111   // SUBS X31, X2, X9        // is j < 12?
01010100_1111111111111101011_01011     // B.LT OUTER_LOOP (-21)   // If so, continue outer loop
1001000100_000000000000_11111_11111    // ADDI X31, X31, #0       // NOOP
            // HALT:
000101_00000000000000000000000000      // B HALT                  // HALT
1001000100_000000000000_11111_11111    // ADDI X31, X31, #0       // NOOP